import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';

const VisualizationCanvas = ({ visualization, isPlaying, setIsPlaying }) => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const [startTime, setStartTime] = useState(null);
  const [layerRefs, setLayerRefs] = useState({});

  // Easing functions for smoother animations
  const easingFunctions = useMemo(() => ({
    // Linear (no easing)
    linear: t => t,
    // Quadratic
    easeInQuad: t => t * t,
    easeOutQuad: t => t * (2 - t),
    easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    // Cubic
    easeInCubic: t => t * t * t,
    easeOutCubic: t => (--t) * t * t + 1,
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    // Elastic
    easeOutElastic: t => {
      const p = 0.3;
      return Math.pow(2, -10 * t) * Math.sin((t - p / 4) * (2 * Math.PI) / p) + 1;
    },
    // Bounce
    easeOutBounce: t => {
      if (t < (1 / 2.75)) {
        return 7.5625 * t * t;
      } else if (t < (2 / 2.75)) {
        return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
      } else if (t < (2.5 / 2.75)) {
        return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
      } else {
        return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
      }
    }
  }), []);

  // Helper function to draw rounded rectangle
  const drawRoundedRect = useCallback((ctx, x, y, width, height, radius, fill, stroke, strokeWidth) => {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    
    ctx.fillStyle = fill || '#000';
    ctx.fill();
    
    if (stroke) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = strokeWidth || 1;
      ctx.stroke();
    }
  }, []);
  
  // Helper function to draw star
  const drawStar = useCallback((ctx, cx, cy, points, outerRadius, innerRadius, fill, stroke, strokeWidth) => {
    ctx.beginPath();
    let step, halfStep, start, n, dx, dy;
    
    step = Math.PI * 2 / points;
    halfStep = step / 2;
    start = -Math.PI / 2;
    
    ctx.moveTo(cx + outerRadius * Math.cos(start), cy + outerRadius * Math.sin(start));
    
    for (n = 1; n <= points * 2; n++) {
      const radius = n % 2 ? innerRadius : outerRadius;
      dx = cx + radius * Math.cos(start + n * halfStep);
      dy = cy + radius * Math.sin(start + n * halfStep);
      ctx.lineTo(dx, dy);
    }
    
    ctx.closePath();
    ctx.fillStyle = fill || '#000';
    ctx.fill();
    
    if (stroke) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = strokeWidth || 1;
      ctx.stroke();
    }
  }, []);
  
  // Helper function to draw images with props
  const drawImageWithProps = useCallback((ctx, img, props) => {
    const x = props.x || 0;
    const y = props.y || 0;
    const width = props.width || img.width;
    const height = props.height || img.height;
    
    if (props.clip && props.clip.type === 'circle') {
      // Draw image in a circular clip
      ctx.beginPath();
      ctx.arc(props.clip.x, props.clip.y, props.clip.radius, 0, Math.PI * 2);
      ctx.clip();
    } else if (props.clip && props.clip.type === 'rect') {
      // Draw image in a rectangular clip
      ctx.beginPath();
      ctx.rect(props.clip.x, props.clip.y, props.clip.width, props.clip.height);
      ctx.clip();
    }
    
    ctx.drawImage(img, x, y, width, height);
  }, []);

  // Draw shapes function
  const drawShape = useCallback((ctx, type, props) => {
    ctx.save();
    
    // Apply global opacity if specified
    if (props.opacity !== undefined) {
      ctx.globalAlpha = props.opacity;
    }
    
    // Apply scaling if specified
    if (props.scaleX !== undefined || props.scaleY !== undefined) {
      const centerX = props.x + (props.width ? props.width / 2 : 0);
      const centerY = props.y + (props.height ? props.height / 2 : 0);
      ctx.translate(centerX, centerY);
      ctx.scale(props.scaleX || 1, props.scaleY || 1);
      ctx.translate(-centerX, -centerY);
    }
    
    // Handle rotation if present
    if (props.rotation !== undefined) {
      const centerX = props.x + (props.width ? props.width / 2 : 0);
      const centerY = props.y + (props.height ? props.height / 2 : 0);
      ctx.translate(centerX, centerY);
      ctx.rotate((props.rotation * Math.PI) / 180);
      ctx.translate(-centerX, -centerY);
    }

    // Apply shadow if specified
    if (props.shadow) {
      ctx.shadowColor = props.shadow.color || 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = props.shadow.blur || 5;
      ctx.shadowOffsetX = props.shadow.offsetX || 2;
      ctx.shadowOffsetY = props.shadow.offsetY || 2;
    }

    switch (type) {
      case 'circle':
        ctx.beginPath();
        ctx.arc(props.x, props.y, props.r, 0, Math.PI * 2);
        ctx.fillStyle = props.fill || '#000';
        ctx.fill();
        if (props.stroke) {
          ctx.strokeStyle = props.stroke;
          ctx.lineWidth = props.strokeWidth || 1;
          ctx.stroke();
        }
        break;
        
      case 'rect':
        if (props.cornerRadius) {
          drawRoundedRect(ctx, props.x, props.y, props.width, props.height, props.cornerRadius, props.fill, props.stroke, props.strokeWidth);
        } else {
          ctx.fillStyle = props.fill || '#000';
          ctx.fillRect(props.x, props.y, props.width, props.height);
          if (props.stroke) {
            ctx.strokeStyle = props.stroke;
            ctx.lineWidth = props.strokeWidth || 1;
            ctx.strokeRect(props.x, props.y, props.width, props.height);
          }
        }
        break;
        
      case 'text':
        if (props.stroke) {
          ctx.strokeStyle = props.stroke;
          ctx.lineWidth = props.strokeWidth || 1;
          ctx.font = `${props.fontWeight || ''} ${props.fontSize || 16}px ${props.fontFamily || 'Arial'}`;
          ctx.textAlign = props.textAlign || 'center';
          ctx.strokeText(props.text, props.x, props.y);
        }
        
        ctx.fillStyle = props.fill || '#000';
        ctx.font = `${props.fontWeight || ''} ${props.fontSize || 16}px ${props.fontFamily || 'Arial'}`;
        ctx.textAlign = props.textAlign || 'center';
        ctx.textBaseline = props.textBaseline || 'middle';
        ctx.fillText(props.text, props.x, props.y);
        break;
        
      case 'image':
        if (props.src) {
          const img = new Image();
          img.src = props.src;
          
          if (img.complete) {
            // If the image is already loaded
            drawImageWithProps(ctx, img, props);
          } else {
            // If the image is still loading
            img.onload = () => {
              drawImageWithProps(ctx, img, props);
            };
          }
        }
        break;
        
      case 'arrow':
        // Draw the arrow line
        ctx.beginPath();
        ctx.moveTo(props.x, props.y);
        ctx.lineTo(props.x + props.dx, props.y + props.dy);
        ctx.strokeStyle = props.color || '#000';
        ctx.lineWidth = props.lineWidth || 2;
        ctx.stroke();
        
        // Calculate the arrow head
        const angle = Math.atan2(props.dy, props.dx);
        const headLength = props.headLength || 10;
        const headWidth = props.headWidth || Math.PI / 6;
        
        ctx.beginPath();
        ctx.moveTo(props.x + props.dx, props.y + props.dy);
        ctx.lineTo(
          props.x + props.dx - headLength * Math.cos(angle - headWidth),
          props.y + props.dy - headLength * Math.sin(angle - headWidth)
        );
        ctx.lineTo(
          props.x + props.dx - headLength * Math.cos(angle + headWidth),
          props.y + props.dy - headLength * Math.sin(angle + headWidth)
        );
        ctx.closePath();
        ctx.fillStyle = props.color || '#000';
        ctx.fill();
        break;
        
      case 'line':
        ctx.beginPath();
        ctx.moveTo(props.x1, props.y1);
        ctx.lineTo(props.x2, props.y2);
        ctx.strokeStyle = props.color || '#000';
        ctx.lineWidth = props.lineWidth || 2;
        
        if (props.dash) {
          ctx.setLineDash(props.dash);
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        break;
        
      case 'polygon':
        if (props.points && props.points.length > 0) {
          ctx.beginPath();
          ctx.moveTo(props.points[0].x, props.points[0].y);
          
          for (let i = 1; i < props.points.length; i++) {
            ctx.lineTo(props.points[i].x, props.points[i].y);
          }
          
          ctx.closePath();
          ctx.fillStyle = props.fill || '#000';
          ctx.fill();
          
          if (props.stroke) {
            ctx.strokeStyle = props.stroke;
            ctx.lineWidth = props.strokeWidth || 1;
            ctx.stroke();
          }
        }
        break;
        
      case 'star':
        drawStar(ctx, props.x, props.y, props.points || 5, props.outerRadius || 30, props.innerRadius || 15, props.fill, props.stroke, props.strokeWidth);
        break;
        
      default:
        console.warn(`Unknown shape type: ${type}`);
    }
    
    ctx.restore();
  }, [drawRoundedRect, drawStar, drawImageWithProps]);

  // Render canvas function
  const renderCanvas = useCallback((elapsed) => {
    const canvas = canvasRef.current;
    if (!canvas || !visualization) return;
    
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Sort layers by z-index if specified
    const sortedLayers = [...visualization.layers].sort((a, b) => {
      const zIndexA = a.props.zIndex || 0;
      const zIndexB = b.props.zIndex || 0;
      return zIndexA - zIndexB;
    });

    // Track if all animations are complete
    let allAnimationsComplete = true;

    // Update and render each layer
    sortedLayers.forEach(layer => {
      const layerRef = layerRefs[layer.id];
      if (!layerRef) return;

      // Process animations for this layer
      const updatedProps = { ...layer.props };
      let layerAnimationComplete = true;
      
      if (layer.animations && layer.animations.length > 0) {
        layer.animations.forEach(anim => {
          // Handle looping animations
          let effectiveElapsed = elapsed;
          if (anim.loop === true && anim.end > anim.start) {
            const animDuration = anim.end - anim.start;
            effectiveElapsed = anim.start + ((elapsed - anim.start) % animDuration);
            // Looping animations are never complete
            layerAnimationComplete = false;
          }
          
          // Only process animation if we're within its time range
          if (effectiveElapsed >= anim.start && effectiveElapsed <= anim.end) {
            layerAnimationComplete = false;
            let progress = (effectiveElapsed - anim.start) / (anim.end - anim.start);
            
            // Apply easing function if specified
            const easingFunction = anim.easing ? 
              (easingFunctions[anim.easing] || easingFunctions.linear) : 
              easingFunctions.linear;
            
            progress = easingFunction(progress);
            
            if (anim.property === 'orbit') {
              // Special case for orbit animation
              const angle = progress * Math.PI * 2;
              updatedProps.x = anim.centerX + Math.cos(angle) * anim.radius;
              updatedProps.y = anim.centerY + Math.sin(angle) * anim.radius;
            } else if (anim.property === 'rotation') {
              // Handle rotation animation
              updatedProps.rotation = anim.from + (anim.to - anim.from) * progress;
            } else if (anim.property === 'path' && anim.points) {
              // Path animation
              const pointIndex = Math.min(
                Math.floor(progress * (anim.points.length - 1)), 
                anim.points.length - 2
              );
              const pathProgress = (progress * (anim.points.length - 1)) - pointIndex;
              
              const p1 = anim.points[pointIndex];
              const p2 = anim.points[pointIndex + 1];
              
              updatedProps.x = p1.x + (p2.x - p1.x) * pathProgress;
              updatedProps.y = p1.y + (p2.y - p1.y) * pathProgress;
            } else if (anim.property === 'scale') {
              // Handle scaling
              updatedProps.scaleX = anim.fromX + (anim.toX - anim.fromX) * progress;
              updatedProps.scaleY = anim.fromY + (anim.toY - anim.fromY) * progress;
            } else if (anim.property === 'opacity') {
              // Handle opacity
              updatedProps.opacity = anim.from + (anim.to - anim.from) * progress;
            } else {
              // Linear interpolation for standard properties
              updatedProps[anim.property] = anim.from + (anim.to - anim.from) * progress;
            }
          } else if (elapsed > anim.end && !anim.loop) {
            // If we're past the end time, set to final value
            if (anim.property === 'orbit') {
              const angle = Math.PI * 2;
              updatedProps.x = anim.centerX + Math.cos(angle) * anim.radius;
              updatedProps.y = anim.centerY + Math.sin(angle) * anim.radius;
            } else if (anim.property === 'rotation') {
              updatedProps.rotation = anim.to;
            } else if (anim.property === 'path' && anim.points) {
              const lastPoint = anim.points[anim.points.length - 1];
              updatedProps.x = lastPoint.x;
              updatedProps.y = lastPoint.y;
            } else if (anim.property === 'scale') {
              updatedProps.scaleX = anim.toX;
              updatedProps.scaleY = anim.toY;
            } else if (anim.property === 'opacity') {
              updatedProps.opacity = anim.to;
            } else {
              updatedProps[anim.property] = anim.to;
            }
          }
        });
      }

      // Update the layer's current properties
      layerRefs[layer.id].currentProps = updatedProps;

      // Render based on shape type
      drawShape(ctx, layer.type, updatedProps);
      
      // Update overall animation status
      if (!layerAnimationComplete) {
        allAnimationsComplete = false;
      }
    });
    
    // If animations are complete and we're playing, stop
    if (allAnimationsComplete && isPlaying && elapsed > 100) {
      setIsPlaying(false);
    }
  }, [visualization, isPlaying, drawShape, layerRefs, easingFunctions, setIsPlaying]);

  // Animation loop function
  const animationLoop = useCallback(() => {
    if (!canvasRef.current || !visualization) return;

    const now = performance.now();
    const elapsed = startTime ? now - startTime : 0;
    
    if (elapsed >= visualization.duration) {
      // Animation complete
      setIsPlaying(false);
      return;
    }

    renderCanvas(elapsed);
    animationRef.current = requestAnimationFrame(animationLoop);
  }, [visualization, startTime, renderCanvas, setIsPlaying]);

  // Reset animation when visualization changes
  useEffect(() => {
    if (visualization) {
      // Create refs for each layer
      const newLayerRefs = {};
      visualization.layers.forEach(layer => {
        newLayerRefs[layer.id] = {
          ...layer,
          currentProps: { ...layer.props }
        };
      });
      setLayerRefs(newLayerRefs);
      setStartTime(null);
    }
  }, [visualization]);

  // Handle play/pause state changes
  useEffect(() => {
    if (isPlaying) {
      if (!startTime) {
        setStartTime(performance.now());
      }
      animationLoop();
    } else {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    }

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isPlaying, startTime, animationLoop]);

  // Canvas resize effect
  useEffect(() => {
    if (canvasRef.current) {
      // Set canvas size to match its container
      const resizeCanvas = () => {
        const canvas = canvasRef.current;
        if (canvas) {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          
          // Re-render immediately if we're not playing
          if (!isPlaying && visualization) {
            renderCanvas(startTime ? performance.now() - startTime : 0);
          }
        }
      };
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      return () => {
        window.removeEventListener('resize', resizeCanvas);
      };
    }
  }, [visualization, isPlaying, renderCanvas, startTime]);

  if (!visualization) {
    return (
      <div className="no-visualization">
        <p>Ask a question to see a visualization</p>
      </div>
    );
  }

  // Check if visualization has the required structure
  const isValidVisualization = visualization && 
    visualization.duration && 
    visualization.fps && 
    Array.isArray(visualization.layers) && 
    visualization.layers.length > 0;

  if (!isValidVisualization) {
    return (
      <div className="no-visualization">
        <p>Invalid visualization data. Please try another question.</p>
      </div>
    );
  }

  return (
    <div className="canvas-container">
      <h2 className="visualization-title">Visualization</h2>
      <canvas ref={canvasRef} />
    </div>
  );
};

export default VisualizationCanvas;
